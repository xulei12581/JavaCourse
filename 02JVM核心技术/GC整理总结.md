GC和堆内存就好像算法与数据结构 两者相辅相成 又是对应关系
GC与堆内存的考察点有下面几个
1.可达性分析
2.方法区回收
3.垃圾回收算法以及对应的垃圾收集器
4.不同收集器的对比

  从可达性的角度分析,一切的回收都是建立在GC Root对象的基础上,再通过对象的引用向下搜索,
遍历引用链,没有被引用到的对象会被标记,会被回收
  GC Root对应有四块
    1.虚拟机栈的对象
	2.方法区中常量引用的对象
	3.方法区类静态属性引用的对象
	4.本地方法栈 Native 方法引用的对象
  当然也有例外,并不是不可达的对象都被回收,如果通过finalize方法重新建立引用,也不会被引用,
  而且也很少会重写finalize方法,所以只能算是特例,只需要注意
  
  方法区回收效率一般都很低,因为里面保存的大量都是类对象和类的静态变量，这些很少会被回收。
一般回收的对象只有两种：废弃的常量和没用的类

  java的底层实现原理大部分都在算法基础上进行,而垃圾回收器对应的算法也需要仔细的研究
垃圾回收算法主要由下列几种,具体的算法描述这边就不写了,太占篇幅了
  引用计数法
  标记清除法
  标记整理法
  复制算法
  标记压缩
  分代算法
而收集器根据所属区域划分主要由下面几种  
  新生代收集器：Serial、ParNew、Parallel Scavenge

  老年代收集器：Serial Old、Parallel Old、CMS

  整堆收集器：G1
  
  首先要明确一下并发垃圾收集和并行垃圾收集的区别,这一点在收集器回收的时候有这明显的差别,
并行是指多条垃圾收集线程并行工作,如ParNew、Parallel Scavenge、Parallel Old,但此时用户线程
仍然处于等待状态,而并发是指用户线程与垃圾收集线程同时执行,如CMS、G1(也有并行)
  其次是不同的回收方式,常说的就是Minor GC和Major GC,其中Major GC又称Full GC,通常Major GC
包含新生代和老年代的收集,Major GC速度一般比Minor GC慢很多,具体多少要视Xmx和回收器决定
  
  最后是不同收集器的对比以及堆内存的分析
  收集器其实在课程里面主要讲了四种,而ZGC/Shenandoah GC这一块只是简单了解了,还没研究清楚,
所以就不做描述了,主要四种就是串行GC和并行GC以及CMS和G1
  Serial/Serial Old 收集器:新生代复制GC清除,老年代标记整理清除,优点是简单高效,适合单核CPU
缺点就是经常Stop the world,不大适合服务器使用,ParNew其实就是Serial的多线程版,一般会和CMS
收集器共同协作,因为CMS是老年代的收集器,并不会对新生代做收集
  Parallel Scavenge/Parallel Old:新生代采用复制算法,老年代采用标记整理压缩的算法,优点是
减少垃圾收集时间,同时减少垃圾的收集次数,同时对吞吐量有很好的处理与控制
  CMS是针对老年代的回收器,采用标记-清除算法,优点是GC执行的效率很快,延迟低,缺点也很明显,
老年代碎片化与CPU的要求
  G1:G1使用了分代收集,把整块的堆空间，划分为固定内存的 region,然后根据新生代与老年代分为
三块,Eden、Survivor和old,回收是并行的,其它线程正常工作,从整体上看属于标记-整理,优点是并行
与并发、分代收集(包括新生代和老年代)、结合多种算法(空间整合 不产生碎片)、低停顿与低延时